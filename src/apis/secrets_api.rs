/*
 * KeyVaultClient
 *
 * The key vault client performs cryptographic key operations and vault operations against the Key Vault service.
 *
 * The version of the OpenAPI document: 7.2
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `backup_secret`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BackupSecretError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_secret`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSecretError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_secret`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSecretError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_secret_versions`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSecretVersionsError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_secrets`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSecretsError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `restore_secret`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestoreSecretError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_secret`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetSecretError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_secret`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSecretError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}


/// Requests that a backup of the specified secret be downloaded to the client. All versions of the secret will be downloaded. This operation requires the secrets/backup permission.
pub async fn backup_secret(configuration: &configuration::Configuration, secret_name: &str, api_version: &str) -> Result<crate::models::BackupSecretResult, Error<BackupSecretError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/secrets/{secret_name}/backup", configuration.base_path, secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BackupSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied to an individual version of a secret. This operation requires the secrets/delete permission.
pub async fn delete_secret(configuration: &configuration::Configuration, secret_name: &str, api_version: &str) -> Result<crate::models::DeletedSecretBundle, Error<DeleteSecretError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/secrets/{secret_name}", configuration.base_path, secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires the secrets/get permission.
pub async fn get_secret(configuration: &configuration::Configuration, secret_name: &str, secret_version: &str, api_version: &str) -> Result<crate::models::SecretBundle, Error<GetSecretError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/secrets/{secret_name}/{secret_version}", configuration.base_path, secret_name=crate::apis::urlencode(secret_name), secret_version=crate::apis::urlencode(secret_version));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The full secret identifier and attributes are provided in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
pub async fn get_secret_versions(configuration: &configuration::Configuration, secret_name: &str, api_version: &str, maxresults: Option<i32>) -> Result<crate::models::SecretListResult, Error<GetSecretVersionsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/secrets/{secret_name}/versions", configuration.base_path, secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = maxresults {
        local_var_req_builder = local_var_req_builder.query(&[("maxresults", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSecretVersionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier and its attributes are provided in the response. Individual secret versions are not listed in the response. This operation requires the secrets/list permission.
pub async fn get_secrets(configuration: &configuration::Configuration, api_version: &str, maxresults: Option<i32>) -> Result<crate::models::SecretListResult, Error<GetSecretsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/secrets", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = maxresults {
        local_var_req_builder = local_var_req_builder.query(&[("maxresults", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSecretsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restores a backed up secret, and all its versions, to a vault. This operation requires the secrets/restore permission.
pub async fn restore_secret(configuration: &configuration::Configuration, api_version: &str, parameters: crate::models::SecretRestoreParameters) -> Result<crate::models::SecretBundle, Error<RestoreSecretError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/secrets/restore", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&parameters);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RestoreSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  The SET operation adds a secret to the Azure Key Vault. If the named secret already exists, Azure Key Vault creates a new version of that secret. This operation requires the secrets/set permission.
pub async fn set_secret(configuration: &configuration::Configuration, secret_name: &str, api_version: &str, parameters: crate::models::SecretSetParameters) -> Result<crate::models::SecretBundle, Error<SetSecretError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/secrets/{secret_name}", configuration.base_path, secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&parameters);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The UPDATE operation changes specified attributes of an existing stored secret. Attributes that are not specified in the request are left unchanged. The value of a secret itself cannot be changed. This operation requires the secrets/set permission.
pub async fn update_secret(configuration: &configuration::Configuration, secret_name: &str, secret_version: &str, api_version: &str, parameters: crate::models::SecretUpdateParameters) -> Result<crate::models::SecretBundle, Error<UpdateSecretError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/secrets/{secret_name}/{secret_version}", configuration.base_path, secret_name=crate::apis::urlencode(secret_name), secret_version=crate::apis::urlencode(secret_version));
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&parameters);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

