/*
 * KeyVaultClient
 *
 * The key vault client performs cryptographic key operations and vault operations against the Key Vault service.
 *
 * The version of the OpenAPI document: 7.2
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `backup_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BackupCertificateError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCertificateError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCertificateError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_certificate_contacts`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCertificateContactsError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_certificate_issuer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCertificateIssuerError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_certificate_operation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCertificateOperationError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertificateError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_certificate_contacts`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertificateContactsError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_certificate_issuer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertificateIssuerError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_certificate_issuers`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertificateIssuersError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_certificate_operation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertificateOperationError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_certificate_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertificatePolicyError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_certificate_versions`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertificateVersionsError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_certificates`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertificatesError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `import_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportCertificateError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `merge_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MergeCertificateError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `restore_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestoreCertificateError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_certificate_contacts`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetCertificateContactsError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_certificate_issuer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetCertificateIssuerError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCertificateError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_certificate_issuer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCertificateIssuerError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_certificate_operation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCertificateOperationError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_certificate_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCertificatePolicyError {
    DefaultResponse(crate::models::KeyVaultError),
    UnknownValue(serde_json::Value),
}


/// Requests that a backup of the specified certificate be downloaded to the client. All versions of the certificate will be downloaded. This operation requires the certificates/backup permission.
pub async fn backup_certificate(configuration: &configuration::Configuration, certificate_name: &str, api_version: &str) -> Result<crate::models::BackupCertificateResult, Error<BackupCertificateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/backup", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BackupCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If this is the first version, the certificate resource is created. This operation requires the certificates/create permission.
pub async fn create_certificate(configuration: &configuration::Configuration, certificate_name: &str, api_version: &str, parameters: crate::models::CertificateCreateParameters) -> Result<crate::models::CertificateOperation, Error<CreateCertificateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/create", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&parameters);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes all versions of a certificate object along with its associated policy. Delete certificate cannot be used to remove individual versions of a certificate object. This operation requires the certificates/delete permission.
pub async fn delete_certificate(configuration: &configuration::Configuration, certificate_name: &str, api_version: &str) -> Result<crate::models::DeletedCertificateBundle, Error<DeleteCertificateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes the certificate contacts for a specified key vault certificate. This operation requires the certificates/managecontacts permission.
pub async fn delete_certificate_contacts(configuration: &configuration::Configuration, api_version: &str) -> Result<crate::models::Contacts, Error<DeleteCertificateContactsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/contacts", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteCertificateContactsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The DeleteCertificateIssuer operation permanently removes the specified certificate issuer from the vault. This operation requires the certificates/manageissuers/deleteissuers permission.
pub async fn delete_certificate_issuer(configuration: &configuration::Configuration, issuer_name: &str, api_version: &str) -> Result<crate::models::IssuerBundle, Error<DeleteCertificateIssuerError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/issuers/{issuer_name}", configuration.base_path, issuer_name=crate::apis::urlencode(issuer_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteCertificateIssuerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes the creation operation for a specified certificate that is in the process of being created. The certificate is no longer created. This operation requires the certificates/update permission.
pub async fn delete_certificate_operation(configuration: &configuration::Configuration, certificate_name: &str, api_version: &str) -> Result<crate::models::CertificateOperation, Error<DeleteCertificateOperationError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/pending", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteCertificateOperationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets information about a specific certificate. This operation requires the certificates/get permission.
pub async fn get_certificate(configuration: &configuration::Configuration, certificate_name: &str, certificate_version: &str, api_version: &str) -> Result<crate::models::CertificateBundle, Error<GetCertificateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/{certificate_version}", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name), certificate_version=crate::apis::urlencode(certificate_version));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The GetCertificateContacts operation returns the set of certificate contact resources in the specified key vault. This operation requires the certificates/managecontacts permission.
pub async fn get_certificate_contacts(configuration: &configuration::Configuration, api_version: &str) -> Result<crate::models::Contacts, Error<GetCertificateContactsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/contacts", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCertificateContactsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The GetCertificateIssuer operation returns the specified certificate issuer resources in the specified key vault. This operation requires the certificates/manageissuers/getissuers permission.
pub async fn get_certificate_issuer(configuration: &configuration::Configuration, issuer_name: &str, api_version: &str) -> Result<crate::models::IssuerBundle, Error<GetCertificateIssuerError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/issuers/{issuer_name}", configuration.base_path, issuer_name=crate::apis::urlencode(issuer_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCertificateIssuerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The GetCertificateIssuers operation returns the set of certificate issuer resources in the specified key vault. This operation requires the certificates/manageissuers/getissuers permission.
pub async fn get_certificate_issuers(configuration: &configuration::Configuration, api_version: &str, maxresults: Option<i32>) -> Result<crate::models::CertificateIssuerListResult, Error<GetCertificateIssuersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/issuers", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = maxresults {
        local_var_req_builder = local_var_req_builder.query(&[("maxresults", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCertificateIssuersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets the creation operation associated with a specified certificate. This operation requires the certificates/get permission.
pub async fn get_certificate_operation(configuration: &configuration::Configuration, certificate_name: &str, api_version: &str) -> Result<crate::models::CertificateOperation, Error<GetCertificateOperationError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/pending", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCertificateOperationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The GetCertificatePolicy operation returns the specified certificate policy resources in the specified key vault. This operation requires the certificates/get permission.
pub async fn get_certificate_policy(configuration: &configuration::Configuration, certificate_name: &str, api_version: &str) -> Result<crate::models::CertificatePolicy, Error<GetCertificatePolicyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/policy", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCertificatePolicyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The GetCertificateVersions operation returns the versions of a certificate in the specified key vault. This operation requires the certificates/list permission.
pub async fn get_certificate_versions(configuration: &configuration::Configuration, certificate_name: &str, api_version: &str, maxresults: Option<i32>) -> Result<crate::models::CertificateListResult, Error<GetCertificateVersionsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/versions", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = maxresults {
        local_var_req_builder = local_var_req_builder.query(&[("maxresults", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCertificateVersionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The GetCertificates operation returns the set of certificates resources in the specified key vault. This operation requires the certificates/list permission.
pub async fn get_certificates(configuration: &configuration::Configuration, api_version: &str, maxresults: Option<i32>, include_pending: Option<bool>) -> Result<crate::models::CertificateListResult, Error<GetCertificatesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = maxresults {
        local_var_req_builder = local_var_req_builder.query(&[("maxresults", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_pending {
        local_var_req_builder = local_var_req_builder.query(&[("includePending", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCertificatesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates. This operation requires the certificates/import permission.
pub async fn import_certificate(configuration: &configuration::Configuration, certificate_name: &str, api_version: &str, parameters: crate::models::CertificateImportParameters) -> Result<crate::models::CertificateBundle, Error<ImportCertificateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/import", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&parameters);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ImportCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The MergeCertificate operation performs the merging of a certificate or certificate chain with a key pair currently available in the service. This operation requires the certificates/create permission.
pub async fn merge_certificate(configuration: &configuration::Configuration, certificate_name: &str, api_version: &str, parameters: crate::models::CertificateMergeParameters) -> Result<crate::models::CertificateBundle, Error<MergeCertificateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/pending/merge", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&parameters);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MergeCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restores a backed up certificate, and all its versions, to a vault. This operation requires the certificates/restore permission.
pub async fn restore_certificate(configuration: &configuration::Configuration, api_version: &str, parameters: crate::models::CertificateRestoreParameters) -> Result<crate::models::CertificateBundle, Error<RestoreCertificateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/restore", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&parameters);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RestoreCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sets the certificate contacts for the specified key vault. This operation requires the certificates/managecontacts permission.
pub async fn set_certificate_contacts(configuration: &configuration::Configuration, api_version: &str, contacts: crate::models::Contacts) -> Result<crate::models::Contacts, Error<SetCertificateContactsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/contacts", configuration.base_path);
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&contacts);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetCertificateContactsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The SetCertificateIssuer operation adds or updates the specified certificate issuer. This operation requires the certificates/setissuers permission.
pub async fn set_certificate_issuer(configuration: &configuration::Configuration, issuer_name: &str, api_version: &str, parameter: crate::models::CertificateIssuerSetParameters) -> Result<crate::models::IssuerBundle, Error<SetCertificateIssuerError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/issuers/{issuer_name}", configuration.base_path, issuer_name=crate::apis::urlencode(issuer_name));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&parameter);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetCertificateIssuerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The UpdateCertificate operation applies the specified update on the given certificate; the only elements updated are the certificate's attributes. This operation requires the certificates/update permission.
pub async fn update_certificate(configuration: &configuration::Configuration, certificate_name: &str, certificate_version: &str, api_version: &str, parameters: crate::models::CertificateUpdateParameters) -> Result<crate::models::CertificateBundle, Error<UpdateCertificateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/{certificate_version}", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name), certificate_version=crate::apis::urlencode(certificate_version));
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&parameters);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The UpdateCertificateIssuer operation performs an update on the specified certificate issuer entity. This operation requires the certificates/setissuers permission.
pub async fn update_certificate_issuer(configuration: &configuration::Configuration, issuer_name: &str, api_version: &str, parameter: crate::models::CertificateIssuerUpdateParameters) -> Result<crate::models::IssuerBundle, Error<UpdateCertificateIssuerError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/issuers/{issuer_name}", configuration.base_path, issuer_name=crate::apis::urlencode(issuer_name));
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&parameter);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateCertificateIssuerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a certificate creation operation that is already in progress. This operation requires the certificates/update permission.
pub async fn update_certificate_operation(configuration: &configuration::Configuration, certificate_name: &str, api_version: &str, certificate_operation: crate::models::CertificateOperationUpdateParameter) -> Result<crate::models::CertificateOperation, Error<UpdateCertificateOperationError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/pending", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name));
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&certificate_operation);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateCertificateOperationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set specified members in the certificate policy. Leave others as null. This operation requires the certificates/update permission.
pub async fn update_certificate_policy(configuration: &configuration::Configuration, certificate_name: &str, api_version: &str, certificate_policy: crate::models::CertificatePolicy) -> Result<crate::models::CertificatePolicy, Error<UpdateCertificatePolicyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{certificate_name}/policy", configuration.base_path, certificate_name=crate::apis::urlencode(certificate_name));
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("api_version", &api_version.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&certificate_policy);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateCertificatePolicyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

